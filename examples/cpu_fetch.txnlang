#include "CoreLib.h"

namespace ecc
{
	def getInsnData(memory_value_t value) -> fetched_instruction_data_t
	{
		return { static_cast<instruction_t>(value), static_cast<instruction_t>(value >> 32) };
	}

	def get_address_to_fetch_from_PC(memory_address_t fetch_PC) -> memory_address_t
	{
		return fetch_PC & ~7;
	}


	def changesControlFlow(Opcode op) -> bool
	{
		switch (op)
		{
		case INSN_OPCODE_HALT:
		case INSN_OPCODE_JMP_ALWAYS:
		case INSN_OPCODE_JMP_EQUAL:
		case INSN_OPCODE_JMP_NOT_EQUAL:
		case INSN_OPCODE_JMP_GREATER:
		case INSN_OPCODE_JMP_GREATER_EQUAL:
		case INSN_OPCODE_JMP_LOWER:
		case INSN_OPCODE_JMP_LOWER_EQUAL:
		case INSN_OPCODE_LOAD_RESTORE_PC:
		{
			return true;
		}
		default:
		{
			return false;
		}
		}
		return false;
	}


	def run(FetchToDecodeBus& decode_bus,
					StoreToFetchBus& store_bus,
					MemoryBus& memory_bus,
					GlobalStats& stats)
	{
		txn {
			bool have_outstanding_jmp = false;
			memory_address_t fetch_PC = 0;
			execution_mask_t exec_mask = ALL_THREADS_EXEC_MASK_INT64;

			memory_address_t address_cached = 0xffffffffffffffff;
			fetched_instruction_data_t insn_data_cached;
		}

		loop
		{
			$display("[FETCH] have outstanding jmp: ", have_outstanding_jmp);

			if (have_outstanding_jmp)
			{
				$display("[FETCH] waiting for store pipline to tell us the cond-jump-address");

				txn_wait store_bus.can_receive;

				txn {
					have_outstanding_jmp = false;
					StoreToFetchPacket jmp_retarget = store_bus.recv();
				}

				txn {
					fetch_PC = jmp_retarget.newpc;
					exec_mask = jmp_retarget.exec_mask;
				}				
			}
	


			$display("[FETCH] testing cache adress");

			if (address_cached == fetch_PC)
			{
				// nothing to do	
				$display("[FETCH] testing cache adress: already have it cached 1");
			}
			else
			{
				if ((address_cached + sizeof(instruction_t)) == fetch_PC)
				{
					// nothing to do.
					$display("[FETCH] testing cache adress: already have it cached 2");
				}
				else
				{
					txn {
						memory_address_t address = get_address_to_fetch_from_PC(fetch_PC);
						BusID busID = createBusID(core_id, COMPONENT_TYPE_FETCH);

						$display("[FETCH] requesting memory at address: ", address);
						memory_bus.send_read_request_data(address, busID);
					}

					txn_wait memory_bus.response_busy;

					txn {
						BusPacket response = memory_bus.get_response();
					}
					
					txn {
						$display("[FETCH] response received from caches: ", response.packet_type);
						assert(response.packet_type == bus_read_response);

						address_cached = get_address_to_fetch_from_PC(fetch_PC);				
						insn_data_cached = getInsnData(response.payload);
					}
				}
			}

			$display("[FETCH] testing cache adress: retrieving from local cache");


			txn {
				instruction_t insn = 0;
				if (address_cached == fetch_PC)
				{
					insn = insn_data_cached[0];
				}
				else
				{
					if ((address_cached + sizeof(instruction_t)) == fetch_PC)
					{
						insn = insn_data_cached[1];
					}
					else
					{
						$error("[FETCH] failed to get insn from local fetcher cache");
						assert(false);
					}
				}
			}

			twn {
				$display("[FETCH] received response for address/insn ", fetch_PC, insn);
				have_outstanding_jmp = changesControlFlow(getOpcode(insn));
			}

			txn_wait not decode_bus.is_busy;

			txn {
				decode_bus.send(create_fetch_decode_packet(exec_mask, fetch_PC, insn));
				fetch_PC += sizeof(instruction_t);
			}
		}
	}
}